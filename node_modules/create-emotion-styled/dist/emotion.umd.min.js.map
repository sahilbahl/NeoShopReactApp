{"version":3,"file":"emotion.umd.min.js","sources":["../../emotion-theming/src/channel.js","../../emotion-theming/src/utils.js","../../../next-packages/is-prop-valid/src/index.js","../../../next-packages/memoize/src/index.js","../src/utils.js","../src/index.js"],"sourcesContent":["// @flow\nexport default '__EMOTION_THEMING__'\n","// @flow\nimport PropTypes from 'prop-types'\nimport channel from './channel'\n\nexport const contextTypes = {\n  [channel]: PropTypes.object\n}\n\nexport { default as channel } from './channel'\nexport { default as createBroadcast } from './create-broadcast'\n\nexport type Theme = Object | ((theme?: Object) => Object)\n","import memoize from '@emotion/memoize'\n\ndeclare var codegen: { require: string => RegExp }\n\nconst reactPropsRegex = codegen.require('./props')\n\nexport default memoize(RegExp.prototype.test.bind(reactPropsRegex))\n","// @flow\n\nexport default function memoize<V>(fn: string => V): string => V {\n  const cache = {}\n\n  return (arg: string) => {\n    if (cache[arg] === undefined) cache[arg] = fn(arg)\n    return cache[arg]\n  }\n}\n","// @flow\nimport isPropValid from '@emotion/is-prop-valid'\nimport type { Interpolations } from 'create-emotion'\n\nexport function setTheme(theme: Object) {\n  this.setState({ theme })\n}\n\nexport const testPickPropsOnStringTag = isPropValid\n\nexport const testPickPropsOnComponent = (key: string) =>\n  key !== 'theme' && key !== 'innerRef'\nexport const testAlwaysTrue = () => true\n\nexport const pickAssign: (\n  testFn: (key: string) => boolean,\n  target: {},\n  ...sources: Array<{}>\n) => Object = function(testFn, target) {\n  let i = 2\n  let length = arguments.length\n  for (; i < length; i++) {\n    let source = arguments[i]\n    let key\n    for (key in source) {\n      if (testFn(key)) {\n        target[key] = source[key]\n      }\n    }\n  }\n  return target\n}\n\nexport type StyledOptions = {\n  e?: string,\n  label?: string,\n  target?: string,\n  shouldForwardProp?: (?string) => boolean\n}\n\ntype CreateStyledComponent = (...args: Interpolations) => *\n\ntype BaseCreateStyled = (\n  tag: any,\n  options?: StyledOptions\n) => CreateStyledComponent\n\nexport type CreateStyled = BaseCreateStyled & {\n  [key: string]: CreateStyledComponent\n}\n","// @flow\nimport type { Emotion, Interpolations } from 'create-emotion'\nimport { channel, contextTypes } from '../../emotion-theming/src/utils'\nimport type { ElementType } from 'react'\nimport typeof ReactType from 'react'\nimport type { CreateStyled, StyledOptions } from './utils'\nimport {\n  testPickPropsOnComponent,\n  testAlwaysTrue,\n  testPickPropsOnStringTag,\n  pickAssign,\n  setTheme\n} from './utils'\n\nfunction createEmotionStyled(emotion: Emotion, view: ReactType) {\n  let createStyled: CreateStyled = (tag, options) => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (tag === undefined) {\n        throw new Error(\n          'You are trying to create a styled element with an undefined component.\\nYou may have forgotten to import it.'\n        )\n      }\n    }\n    let staticClassName\n    let identifierName\n    let stableClassName\n    let shouldForwardProp\n    if (options !== undefined) {\n      staticClassName = options.e\n      identifierName = options.label\n      stableClassName = options.target\n      shouldForwardProp =\n        tag.__emotion_forwardProp && options.shouldForwardProp\n          ? propName =>\n              tag.__emotion_forwardProp(propName) &&\n              // $FlowFixMe\n              options.shouldForwardProp(propName)\n          : options.shouldForwardProp\n    }\n    const isReal = tag.__emotion_real === tag\n    const baseTag =\n      staticClassName === undefined\n        ? (isReal && tag.__emotion_base) || tag\n        : tag\n\n    if (typeof shouldForwardProp !== 'function') {\n      shouldForwardProp =\n        typeof baseTag === 'string' &&\n        baseTag.charAt(0) === baseTag.charAt(0).toLowerCase()\n          ? testPickPropsOnStringTag\n          : testPickPropsOnComponent\n    }\n\n    return function() {\n      let args = arguments\n      let styles =\n        isReal && tag.__emotion_styles !== undefined\n          ? tag.__emotion_styles.slice(0)\n          : []\n      if (identifierName !== undefined) {\n        styles.push(`label:${identifierName};`)\n      }\n      if (staticClassName === undefined) {\n        if (args[0] == null || args[0].raw === undefined) {\n          styles.push.apply(styles, args)\n        } else {\n          styles.push(args[0][0])\n          let len = args.length\n          let i = 1\n          for (; i < len; i++) {\n            styles.push(args[i], args[0][i])\n          }\n        }\n      }\n\n      class Styled extends view.Component<*, { theme: Object }> {\n        unsubscribe: number\n        mergedProps: Object\n        static toString: () => string\n        static __emotion_real: any\n        static __emotion_styles: Interpolations\n        static __emotion_base: Styled\n        static __emotion_target: string\n        static __emotion_forwardProp: void | (string => boolean)\n        static withComponent: (ElementType, options?: StyledOptions) => any\n\n        componentWillMount() {\n          if (this.context[channel] !== undefined) {\n            this.unsubscribe = this.context[channel].subscribe(\n              setTheme.bind(this)\n            )\n          }\n        }\n        componentWillUnmount() {\n          if (this.unsubscribe !== undefined) {\n            this.context[channel].unsubscribe(this.unsubscribe)\n          }\n        }\n        render() {\n          const { props, state } = this\n          this.mergedProps = pickAssign(testAlwaysTrue, {}, props, {\n            theme: (state !== null && state.theme) || props.theme || {}\n          })\n\n          let className = ''\n          let classInterpolations = []\n\n          if (props.className) {\n            if (staticClassName === undefined) {\n              className += emotion.getRegisteredStyles(\n                classInterpolations,\n                props.className\n              )\n            } else {\n              className += `${props.className} `\n            }\n          }\n          if (staticClassName === undefined) {\n            className += emotion.css.apply(\n              this,\n              styles.concat(classInterpolations)\n            )\n          } else {\n            className += staticClassName\n          }\n\n          if (stableClassName !== undefined) {\n            className += ` ${stableClassName}`\n          }\n\n          return view.createElement(\n            baseTag,\n            // $FlowFixMe\n            pickAssign(shouldForwardProp, {}, props, {\n              className,\n              ref: props.innerRef\n            })\n          )\n        }\n      }\n      Styled.displayName =\n        identifierName !== undefined\n          ? identifierName\n          : `Styled(${\n              typeof baseTag === 'string'\n                ? baseTag\n                : baseTag.displayName || baseTag.name || 'Component'\n            })`\n\n      if (tag.defaultProps !== undefined) {\n        // $FlowFixMe\n        Styled.defaultProps = tag.defaultProps\n      }\n      Styled.contextTypes = contextTypes\n      Styled.__emotion_styles = styles\n      Styled.__emotion_base = baseTag\n      Styled.__emotion_real = Styled\n      Styled.__emotion_forwardProp = shouldForwardProp\n      Object.defineProperty(Styled, 'toString', {\n        enumerable: false,\n        value() {\n          if (\n            process.env.NODE_ENV !== 'production' &&\n            stableClassName === undefined\n          ) {\n            return 'NO_COMPONENT_SELECTOR'\n          }\n          // $FlowFixMe\n          return `.${stableClassName}`\n        }\n      })\n\n      Styled.withComponent = (\n        nextTag: ElementType,\n        nextOptions?: StyledOptions\n      ) => {\n        return createStyled(\n          nextTag,\n          nextOptions !== undefined\n            ? // $FlowFixMe\n              pickAssign(testAlwaysTrue, {}, options, nextOptions)\n            : options\n        )(...styles)\n      }\n\n      return Styled\n    }\n  }\n  if (process.env.NODE_ENV !== 'production' && typeof Proxy !== 'undefined') {\n    createStyled = new Proxy(createStyled, {\n      get(target, property) {\n        switch (property) {\n          // react-hot-loader tries to access this stuff\n          case '__proto__':\n          case 'name':\n          case 'prototype':\n          case 'displayName': {\n            return target[property]\n          }\n          default: {\n            throw new Error(\n              `You're trying to use the styled shorthand without babel-plugin-emotion.` +\n                `\\nPlease install and setup babel-plugin-emotion or use the function call syntax(\\`styled('${property}')\\` instead of \\`styled.${property}\\`)`\n            )\n          }\n        }\n      }\n    })\n  }\n  return createStyled\n}\n\nexport default createEmotionStyled\n"],"names":["contextTypes","channel","PropTypes","object","fn","cache","testPickPropsOnStringTag","RegExp","prototype","test","bind","arg","undefined","testPickPropsOnComponent","key","testAlwaysTrue","pickAssign","testFn","target","i","length","arguments","source","emotion","view","createStyled","tag","options","staticClassName","identifierName","stableClassName","shouldForwardProp","e","label","__emotion_forwardProp","propName","isReal","__emotion_real","baseTag","__emotion_base","charAt","toLowerCase","args","styles","__emotion_styles","slice","push","raw","apply","len","Styled","componentWillMount","this","context","unsubscribe","subscribe","theme","setState","componentWillUnmount","render","props","state","mergedProps","className","classInterpolations","getRegisteredStyles","css","concat","createElement","innerRef","Component","displayName","name","defaultProps","defineProperty","withComponent","nextTag","nextOptions"],"mappings":"6RACe,sBCGFA,UACVC,GAAUC,EAAUC,UCDvB,ICFmCC,EAC3BC,ECKD,IAAMC,GDNsBF,EDIZG,OAAOC,UAAUC,KAAKC,mwHCHrCL,EAAQ,GAEP,SAACM,eACaC,IAAfP,EAAMM,KAAoBN,EAAMM,GAAOP,EAAGO,IACvCN,EAAMM,KCGJE,EAA2B,SAACC,SAC/B,UAARA,GAA2B,aAARA,GACRC,EAAiB,kBAAM,GAEvBC,EAIC,SAASC,EAAQC,WACzBC,EAAI,EACJC,EAASC,UAAUD,OAChBD,EAAIC,EAAQD,IAAK,KAClBG,EAASD,UAAUF,GACnBL,aACCA,KAAOQ,EACNL,EAAOH,OACFA,GAAOQ,EAAOR,WAIpBI,UChBT,SAA6BK,EAAkBC,OACzCC,EAA6B,SAACC,EAAKC,OAQjCC,EACAC,EACAC,EACAC,OACYnB,IAAZe,MACgBA,EAAQK,IACTL,EAAQM,QACPN,EAAQT,SAExBQ,EAAIQ,uBAAyBP,EAAQI,kBACjC,mBACEL,EAAIQ,sBAAsBC,MAElBJ,kBAAkBI,IAC5BR,EAAQI,uBAEVK,EAASV,EAAIW,iBAAmBX,EAChCY,OACgB1B,IAApBgB,GACKQ,GAAUV,EAAIa,gBACfb,QAE2B,mBAAtBK,MAEY,iBAAZO,GACPA,EAAQE,OAAO,KAAOF,EAAQE,OAAO,GAAGC,cACpCnC,EACAO,GAGD,eACD6B,EAAOrB,UACPsB,EACFP,QAAmCxB,IAAzBc,EAAIkB,iBACVlB,EAAIkB,iBAAiBC,MAAM,GAC3B,WACiBjC,IAAnBiB,KACKiB,cAAcjB,YAECjB,IAApBgB,KACa,MAAXc,EAAK,SAA8B9B,IAAhB8B,EAAK,GAAGK,MACtBD,KAAKE,MAAML,EAAQD,OACrB,GACEI,KAAKJ,EAAK,GAAG,YAChBO,EAAMP,EAAKtB,OACXD,EAAI,EACDA,EAAI8B,EAAK9B,MACP2B,KAAKJ,EAAKvB,GAAIuB,EAAK,GAAGvB,QAK7B+B,0LAWJC,mCACgCvC,IAA1BwC,KAAKC,QAAQpD,UACVqD,YAAcF,KAAKC,QAAQpD,GAASsD,UDpF9C,SAAkBC,QAClBC,SAAS,YCoFO/C,KAAK0C,WAIpBM,qCAC2B9C,IAArBwC,KAAKE,kBACFD,QAAQpD,GAASqD,YAAYF,KAAKE,gBAG3CK,sBACUC,EAAiBR,KAAjBQ,MAAOC,EAAUT,KAAVS,WACVC,YAAc9C,EAAWD,EAAgB,GAAI6C,EAAO,OACrC,OAAVC,GAAkBA,EAAML,OAAUI,EAAMJ,OAAS,SAGvDO,EAAY,GACZC,EAAsB,UAEtBJ,EAAMG,oBACgBnD,IAApBgB,EACWL,EAAQ0C,oBACnBD,EACAJ,EAAMG,WAGQH,EAAMG,uBAGFnD,IAApBgB,EACWL,EAAQ2C,IAAIlB,MACvBI,KACAT,EAAOwB,OAAOH,IAGHpC,OAGShB,IAApBkB,WACeA,GAGZN,EAAK4C,cACV9B,IAEWP,EAAmB,GAAI6B,EAAO,iBAElCA,EAAMS,gBA5DE7C,EAAK8C,oBAiEnBC,iBACc3D,IAAnBiB,EACIA,aAEqB,iBAAZS,EACHA,EACAA,EAAQiC,aAAejC,EAAQkC,MAAQ,sBAG1B5D,IAArBc,EAAI+C,iBAECA,aAAe/C,EAAI+C,gBAErBzE,aAAeA,IACf4C,iBAAmBD,IACnBJ,eAAiBD,KACjBD,eAAiBa,GACjBhB,sBAAwBH,SACxB2C,eAAexB,EAAQ,WAAY,aAC5B,6BASCpB,OAIR6C,cAAgB,SACrBC,EACAC,UAEOpD,EACLmD,OACgBhE,IAAhBiE,IAEe9D,EAAgB,GAAIY,EAASkD,GACxClD,gBACDgB,IAGAO,WAwBJzB"}